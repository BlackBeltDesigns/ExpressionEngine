<?php

namespace EllisLab\ExpressionEngine\Service\Database\Backup;

use EllisLab\ExpressionEngine\Service\Logger;

/**
 * ExpressionEngine - by EllisLab
 *
 * @package		ExpressionEngine
 * @author		EllisLab Dev Team
 * @copyright	Copyright (c) 2003 - 2016, EllisLab, Inc.
 * @license		https://expressionengine.com/license
 * @link		https://ellislab.com
 * @since		Version 4.0
 * @filesource
 */

// ------------------------------------------------------------------------

/**
 * ExpressionEngine Database Backup Class
 *
 * @package		ExpressionEngine
 * @subpackage	Database
 * @category	Service
 * @author		EllisLab Dev Team
 * @link		https://ellislab.com
 */
class Backup {

	/**
	 * @var Backup\Query Database Query object
	 */
	protected $query;

	/**
	 * @var Logger\File File object object
	 */
	protected $logger;

	public function __construct(Query $query, Logger\File $logger)
	{
		$this->query = $query;
		$this->logger = $logger;
	}

	/**
	 * Runs the entire database backup routine
	 */
	public function run()
	{
		$this->startFile();
		$this->writeDropAndCreateStatements();
		$this->writeAllTableInserts();
	}

	/**
	 * Creates/truncates any existing backup file at the specified path and
	 * inserts a header
	 */
	public function startFile()
	{
		$this->logger->truncate();
		$this->writeSeparator('Database backup generated by ExpressionEngine');
	}

	/**
	 * Writes the DROP IF EXISTS and CREATE TABLE statements for each table
	 */
	public function writeDropAndCreateStatements()
	{
		$tables = $this->query->getTables();

		$this->writeSeparator('Drop old tables if exists');

		foreach ($tables as $table)
		{
			$this->writeChunk($this->query->getDropStatement($table));
		}

		$this->writeSeparator('CREATE TABLE statements');

		foreach ($tables as $table)
		{
			$this->writeChunk($this->query->getCreateForTable($table));
		}
	}

	/**
	 * Writes ALL table INSERTs
	 */
	public function writeAllTableInserts()
	{
		foreach ($this->query->getTables() as $table)
		{
			$offset = $this->writeInsertsForTableWithOffset($table);

			while ($offset > 0)
			{
				$offset = $this->writeInsertsForTableWithOffset($table, $offset);
			}
		}
	}

	public function writeTableInsertsConservatively()
	{
		// return ['table_name' => 'x', 'offset' => 'x']
	}

	/**
	 * Writes partial INSERTs for a given table, with the idea being a backup
	 * can be split up across multiple requests for large databases
	 *
	 * @param	string	$table_name	Table name
	 * @param	int		$offset		Offset to start the backup from
	 * @return	int		Next offset to start from
	 */
	public function writeInsertsForTableWithOffset($table_name, $offset = 0)
	{
		$default_offset = 5000;

		$total_rows = $this->query->getTotalRows($table_name);

		// Starting from the beginning? Write initial INSERT since we are doing
		// compact INSERTs
		if ($offset == 0 && $total_rows > 0)
		{
			$this->writeChunk(
				$this->query->getInitialInsertForTable($table_name)
			);
		}

		// We need to determine if this is the last batch of insert values we
		// are getting to determine whether to end with a , or a ;
		$end_of_inserts = $total_rows - $offset - $default_offset <= 0;
		$inserts = $this->query->getInsertsForTable($table_name, $offset, $default_offset, $end_of_inserts);

		foreach ($inserts as $insert)
		{
			$this->writeChunk($insert);
		}

		// Still more to go? Notify the caller of the new offset to start from
		if ( ! $end_of_inserts)
		{
			return $offset + $default_offset;
		}

		// End of this table, write a newline
		$this->writeChunk('');
		return 0;
	}

	/**
	 * Writes a chunk of text to the file, Logger class automatically adds a
	 * newline character
	 *
	 * @param	string	$chunk	Chunk to write to the file. Sloth love Chunk.
	 */
	protected function writeChunk($chunk)
	{
		$this->logger->log($chunk);
	}

	/**
	 * Writes a pretty(ish) separator to the file with a given string of text,
	 * usually to mark a new section in the file
	 *
	 * @param	string	$text	Text to include in the separater
	 */
	protected function writeSeparator($text)
	{
		$separator = <<<EOT

--
-- $text
--

EOT;
		$this->logger->log($separator);
	}
}

// EOF
