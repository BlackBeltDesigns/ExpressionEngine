<?php

namespace EllisLab\ExpressionEngine\Service\Database\Backup;

use EllisLab\ExpressionEngine\Service\Logger;

/**
 * ExpressionEngine - by EllisLab
 *
 * @package		ExpressionEngine
 * @author		EllisLab Dev Team
 * @copyright	Copyright (c) 2003 - 2016, EllisLab, Inc.
 * @license		https://expressionengine.com/license
 * @link		https://ellislab.com
 * @since		Version 4.0
 * @filesource
 */

// ------------------------------------------------------------------------

/**
 * ExpressionEngine Database Backup Class
 *
 * @package		ExpressionEngine
 * @subpackage	Database
 * @category	Service
 * @author		EllisLab Dev Team
 * @link		https://ellislab.com
 */
class Backup {

	/**
	 * @var Backup\Query Database Query object
	 */
	protected $query;

	/**
	 * @var Logger\File File object object
	 */
	protected $logger;

	/**
	 * @var boolean When TRUE, writes a file that has one query per line with no
	 * linebreaks in those queries for easy line-by-line consumption by a
	 * restore script
	 */
	protected $compact_file = FALSE;

	/**
	 * Constructor
	 *
	 * @param	Backup\Query	$query	Query object for generating query strings
	 * @param	Logger\File		$logger	Logger object for writing to files
	 */
	public function __construct(Query $query, Logger\File $logger)
	{
		$this->query = $query;
		$this->logger = $logger;
	}

	/**
	 * Class will write a file with comments and helpful whitespace formatting
	 */
	public function makePrettyFile()
	{
		$this->compact_file = FALSE;
		$this->query->makePrettyQueries();
	}

	/**
	 * Class will write a file that has one query per line with no linebreaks in
	 * those queries for easy line-by-line consumption by a restore script
	 */
	public function makeCompactFile()
	{
		$this->compact_file = TRUE;
		$this->query->makeCompactQueries();
	}

	/**
	 * Runs the entire database backup routine
	 */
	public function run()
	{
		$this->startFile();
		$this->writeDropAndCreateStatements();
		$this->writeAllTableInserts();
	}

	/**
	 * Creates/truncates any existing backup file at the specified path and
	 * inserts a header
	 */
	public function startFile()
	{
		$this->logger->truncate();
		$this->writeSeparator('Database backup generated by ExpressionEngine');
	}

	/**
	 * Writes the DROP IF EXISTS and CREATE TABLE statements for each table
	 */
	public function writeDropAndCreateStatements()
	{
		$tables = $this->query->getTables();

		$this->writeSeparator('Drop old tables if exists');

		foreach ($tables as $table)
		{
			$this->writeChunk($this->query->getDropStatement($table));
		}

		$this->writeSeparator('Create tables and their structure');

		foreach ($tables as $table)
		{
			$create = $this->query->getCreateForTable($table);

			// Add an extra linebreak if not a compact file
			if ( ! $this->compact_file)
			{
				$create .= "\n";
			}

			$this->writeChunk($create);
		}
	}

	/**
	 * Writes ALL table INSERTs
	 */
	public function writeAllTableInserts()
	{
		$this->writeSeparator('Populate tables with their data');

		foreach ($this->query->getTables() as $table)
		{
			$offset = $this->writeInsertsForTableWithOffset($table);

			while ($offset > 0)
			{
				$offset = $this->writeInsertsForTableWithOffset($table, $offset);
			}
		}
	}

	public function writeTableInsertsConservatively()
	{
		// return ['table_name' => 'x', 'offset' => 'x']
	}

	/**
	 * Writes partial INSERTs for a given table, with the idea being a backup
	 * can be split up across multiple requests for large databases
	 *
	 * @param	string	$table_name	Table name
	 * @param	int		$offset		Offset to start the backup from
	 * @return	int		Next offset to start from
	 */
	public function writeInsertsForTableWithOffset($table_name, $offset = 0)
	{
		$default_offset = 5000;

		$total_rows = $this->query->getTotalRows($table_name);

		if ($total_rows - $offset <= 0)
		{
			return 0;
		}

		$this->writeChunk(
			$this->query->getInsertsForTable($table_name, $offset, $default_offset)
		);

		// Add another line break if not compact
		if ( ! $this->compact_file)
		{
			$this->writeChunk('');
		}

		// Still more to go? Notify the caller of the new offset to start from
		if ($total_rows - $offset > 0)
		{
			return $offset + $default_offset;
		}

		return 0;
	}

	/**
	 * Writes a chunk of text to the file, Logger class automatically adds a
	 * newline character
	 *
	 * @param	string	$chunk	Chunk to write to the file. Sloth love Chunk.
	 */
	protected function writeChunk($chunk)
	{
		$this->logger->log($chunk);
	}

	/**
	 * Writes a pretty(ish) separator to the file with a given string of text,
	 * usually to mark a new section in the file
	 *
	 * @param	string	$text	Text to include in the separater
	 */
	protected function writeSeparator($text)
	{
		if ($this->compact_file)
		{
			return;
		}

		$separator = <<<EOT

--
-- $text
--

EOT;
		$this->logger->log($separator);
	}
}

// EOF
